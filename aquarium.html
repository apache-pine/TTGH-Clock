<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="red fish.png" type="image/png">
  <title>Aquarium Countdown</title>
  <style>
    /* Full-screen host; grid centers the aquarium in the viewport. */
    html, body { height: 100%; margin: 0; }
    body {
      background: #04121f;
      display: grid;
      place-items: center;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Main aquarium frame with rounded corners, gradient water, and drop shadow. */
    #wrap {
      width: min(1100px, 96vw);
      height: min(700px, 88vh);
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      background:
        radial-gradient(1200px 700px at 50% 30%, rgba(44, 155, 210, .25), transparent 60%),
        linear-gradient(180deg, #06233a 0%, #04121f 60%, #020a12 100%);
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* Hover-only readout for the number of fish (minutes remaining). */
    #count-hover-zone{
    position: absolute;
    left: 0;
    bottom: 0;
    width: 50px;
    height: 20px;
    background: transparent;
    }

    #count-hover-zone span{
    position: absolute;
    left: 14px;
    bottom: 10px;
    color: rgba(255,255,255,.7);
    font-size: 12px;
    user-select: none;
    text-shadow: 0 1px 2px rgba(0,0,0,.6);
    opacity: 0;
    transition: opacity 120ms ease;
    pointer-events: none; /* only the zone handles hover */
    }

    #count-hover-zone:hover span{
    opacity: 1;
    }

    /* Settings gear button pinned to the top-right of the aquarium. */
    .settings-button {
      position: absolute;
      top: 12px;
      right: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(2,6,23,.75);
      color: rgba(255,255,255,.9);
      width: 2rem;
      height: 2rem;
      font-size: 1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(6px);
    }
    .settings-button:hover {
      background: rgba(17,24,39,.85);
    }

    /* Floating settings panel for editing the home (end) time. */
    .settings-panel {
      position: absolute;
      top: 52px;
      right: 12px;
      background: rgba(2,6,23,.92);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 0.5rem;
      padding: 0.75rem 0.9rem;
      font-size: 0.85rem;
      color: rgba(255,255,255,.9);
      min-width: 210px;
      z-index: 50;
      backdrop-filter: blur(8px);
    }
    .settings-panel.hidden { display: none; }

    .settings-header {
      font-weight: 600;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.6rem;
    }

    .settings-row label { flex: 1; }

    .settings-row input[type="time"] {
      flex: 1;
      background: rgba(2,6,23,.6);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 0.375rem;
      color: rgba(255,255,255,.9);
      padding: 0.15rem 0.3rem;
      font-size: 0.85rem;
    }

    .settings-row select {
      flex: 1;
      background: rgba(2,6,23,.6);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 0.375rem;
      color: rgba(255,255,255,.9);
      padding: 0.15rem 0.3rem;
      font-size: 0.85rem;
    }

    .settings-actions {
      display: flex;
      justify-content: flex-end;
      gap: 0.4rem;
      margin-top: 0.2rem;
    }

    .settings-actions button {
      padding: 0.25rem 0.6rem;
      border-radius: 0.375rem;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(17,24,39,.85);
      color: rgba(255,255,255,.9);
      font-size: 0.82rem;
      cursor: pointer;
    }
    .settings-actions button:hover {
      background: rgba(31,41,55,.95);
    }

    .settings-row input[type="range"] {
      flex: 1;
    }

    .settings-row button {
      flex: 1;
      padding: 0.25rem 0.6rem;
      border-radius: 0.375rem;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(17,24,39,.85);
      color: rgba(255,255,255,.9);
      font-size: 0.82rem;
      cursor: pointer;
    }
    .settings-row button:hover {
      background: rgba(31,41,55,.95);
    }
  </style>
</head>
<body>
  <!--
    Layout:
    - #wrap: visual aquarium container.
    - canvas: where fish are drawn.
    - settings gear/panel: edit home time.
    - count-hover-zone: hidden text showing minutes (fish count) on hover.
  -->
  <div id="wrap">
    <audio id="bg-audio" src="water-ambience.mp3" loop preload="auto"></audio>
    <audio id="sfx-poof" src="poof.mp3" preload="auto"></audio>
    <canvas id="c"></canvas>

    <button id="settings-btn" class="settings-button" type="button" aria-label="Settings">⚙</button>

    <div id="settings-panel" class="settings-panel hidden">
      <div class="settings-header">Aquarium Settings</div>
      <div class="settings-row">
        <label for="home-day">Day</label>
        <select id="home-day">
          <option value="today">Today</option>
          <option value="tomorrow">Tomorrow</option>
        </select>
      </div>

      <div class="settings-row">
        <label for="home-time">H</label>
        <input id="home-time" type="time">
      </div>
      <div class="settings-actions">
        <button id="settings-save" type="button">Save</button>
        <button id="settings-cancel" type="button">Cancel</button>
      </div>
      <div class="settings-header">Sound</div>

      <div class="settings-row">
        <label for="bg-mute">Background</label>
        <button id="bg-mute" type="button">Mute</button>
      </div>
      <div class="settings-row">
        <label for="bg-vol">BG Vol</label>
        <input id="bg-vol" type="range" min="0" max="100" value="20">
      </div>

      <div class="settings-row">
        <label for="sfx-mute">SFX</label>
        <button id="sfx-mute" type="button">Mute</button>
      </div>
      <div class="settings-row">
        <label for="sfx-vol">SFX Vol</label>
        <input id="sfx-vol" type="range" min="0" max="100" value="60">
      </div>
    </div>

    <div id="count-hover-zone"><span id="fish-left">0</span></div>
  </div>

<script>
(() => {
  /*
    High-level flow:
    - Keep a Pacific-time countdown to "home" (H) stored target day in localStorage.
    - Map minutes remaining to fish count (capped) and render animated fish with boids-like motion.
    - Run a 24 fps physics loop for smooth motion, and a separate minute-aligned timer for countdown updates.
    - UI lets user change H via a small gear-backed settings panel.
  */

  // =============================
  // Countdown Settings (Pacific)
  // =============================
  const SETTINGS_KEY = "aquariumEndTimeSettings";
  const DEFAULT_HOME_MINUTES = 17 * 60; // 17:00 default end time
  const AUDIO_KEY = "aquariumAudioSettings";
  const DEFAULT_AUDIO = {
    bgVol: 0.20,
    bgMuted: false,
    sfxVol: 0.60,
    sfxMuted: false
  };

  function getPacificComponents() {
    const now = new Date();
    // Use Intl to obtain Pacific components independent of user machine timezone.
    const formatter = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/Los_Angeles",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    });
    const parts = formatter.formatToParts(now);
    const get = type => parts.find(p => p.type === type).value;
    return {
      year: Number(get("year")),
      month: Number(get("month")),
      day: Number(get("day")),
      hour: Number(get("hour")),
      minute: Number(get("minute"))
    };
  }

  function getPacificDateKey(pac) {
    const m = pac.month.toString().padStart(2, "0");
    const d = pac.day.toString().padStart(2, "0");
    // YYYY-MM-DD key keeps per-day settings isolated and auto-resets at midnight.
    return pac.year + "-" + m + "-" + d;
  }

  function timeStringToMinutes(str) {
    if (!str) return null;
    // Parse HH:MM into minutes since midnight; reject invalid numbers or ranges.
    const [hStr, mStr] = str.split(":");
    const h = Number(hStr);
    const m = Number(mStr);
    if (!Number.isFinite(h) || !Number.isFinite(m)) return null;
    const total = h * 60 + m;
    if (total < 0 || total >= 24 * 60) return null;
    return total;
  }

  function minutesToTimeString(minutes) {
    // Normalize to 0..1439 then format back to HH:MM for inputs and tooltips.
    let m = minutes % (24 * 60);
    if (m < 0) m += 24 * 60;
    const h = Math.floor(m / 60);
    const min = m % 60;
    return h.toString().padStart(2, "0") + ":" + min.toString().padStart(2, "0");
  }

  function getTargetSettings(pac) {
    const todayKey = getPacificDateKey(pac);
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) {
        return { targetDate: todayKey, homeMinutes: DEFAULT_HOME_MINUTES };
      }
      const parsed = JSON.parse(raw);
      if (!parsed) return { targetDate: todayKey, homeMinutes: DEFAULT_HOME_MINUTES };

      const targetDate = typeof parsed.targetDate === "string" ? parsed.targetDate : todayKey;
      const homeMinutes = Number.isFinite(parsed.homeMinutes) ? parsed.homeMinutes : DEFAULT_HOME_MINUTES;

      // If the stored target date is in the past, keep it (so it stays at 0) until user changes it.
      return { targetDate, homeMinutes };
    } catch {
      return { targetDate: todayKey, homeMinutes: DEFAULT_HOME_MINUTES };
    }
  }

  function saveTargetSettings(targetDate, homeMinutes) {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify({ targetDate, homeMinutes }));
  }

  function minutesLeftUntilHome() {
    const pac = getPacificComponents();
    const nowMinutes = pac.hour * 60 + pac.minute;
    const todayKey = getPacificDateKey(pac);

    const s = getTargetSettings(pac);
    const targetKey = s.targetDate;

    if (targetKey === todayKey) {
      return { pac, homeMinutes: s.homeMinutes, left: s.homeMinutes - nowMinutes };
    }

    // Target is tomorrow (or a future date, but we only expose tomorrow in UI)
    if (targetKey > todayKey) {
      const leftToday = (24 * 60) - nowMinutes;
      return { pac, homeMinutes: s.homeMinutes, left: leftToday + s.homeMinutes };
    }

    // Target date is in the past -> expired
    return { pac, homeMinutes: s.homeMinutes, left: -1 };
  }

  function loadAudioSettings() {
    try {
      const raw = localStorage.getItem(AUDIO_KEY);
      if (!raw) return { ...DEFAULT_AUDIO };
      const p = JSON.parse(raw) || {};
      return {
        bgVol: Number.isFinite(p.bgVol) ? clamp(p.bgVol, 0, 1) : DEFAULT_AUDIO.bgVol,
        bgMuted: !!p.bgMuted,
        sfxVol: Number.isFinite(p.sfxVol) ? clamp(p.sfxVol, 0, 1) : DEFAULT_AUDIO.sfxVol,
        sfxMuted: !!p.sfxMuted
      };
    } catch {
      return { ...DEFAULT_AUDIO };
    }
  }

  function saveAudioSettings(s) {
    localStorage.setItem(AUDIO_KEY, JSON.stringify(s));
  }

  // =============================
  // Config (Aquarium)
  // =============================
  const TARGET_FPS = 24;
  const DT = 1 / TARGET_FPS;

  // Fish count is driven by countdown now (minutes remaining).
  let FISH_COUNT = 0;

  // Sprite sheet settings
  const SPRITE_URL = "fish.png";
  const SHEET_COLS = 4;
  const SHEET_ROWS = 2;
  const FRAMES_TOTAL = SHEET_COLS * SHEET_ROWS;
  const ANIM_FPS = 8;

  // Behavior tuning
  const MAX_SPEED_MIN = 30;
  const MAX_SPEED_MAX = 85;
  const TURN_RATE_MIN = 0.8;
  const TURN_RATE_MAX = 2.2;

  const FLIP_EPS = 12;

  const WANDER_STRENGTH = 20;
  const WANDER_JITTER = 50;
  const WALL_AVOID_DIST = 200;
  const WALL_AVOID_FORCE = 2.0;

  // Separation (light)
  const SEP_RADIUS = 24;
  const SEP_FORCE = 0.55;

  // Pauses
  const PAUSE_CHANCE_PER_SEC = 0.06;
  const PAUSE_MIN = 0.15;
  const PAUSE_MAX = 0.55;
  const PAUSE_SLOWDOWN = 0.20;

  // Depth
  const SCALE_MIN = 0.35;
  const SCALE_MAX = 0.95;

  // Spatial grid for separation
  const CELL_SIZE = Math.max(SEP_RADIUS * 2, 40);

  // Hard cap so you don't accidentally render 1000+ if your end time is far away
  const MAX_FISH_CAP = 800;

  // =============================
  // Despawn effects (puff + bubbles)
  // =============================
  const PUFF_LIFE = 0.28;          // seconds
  const PUFF_PIECES = 10;          // how many little blobs in the puff
  const PUFF_START_R = 2.5;        // starting blob radius (px)
  const PUFF_END_R = 10;           // ending blob radius (px)

  const BUBBLE_COUNT_MIN = 10;
  const BUBBLE_COUNT_MAX = 16;
  const BUBBLE_LIFE_MIN = 1.4;     // seconds
  const BUBBLE_LIFE_MAX = 2.6;
  const BUBBLE_R_MIN = 1.5;        // px
  const BUBBLE_R_MAX = 3.5;
  const BUBBLE_RISE_MIN = 20;      // px/s upward
  const BUBBLE_RISE_MAX = 55;
  const BUBBLE_DRIFT = 18;         // px/s sideways drift amplitude

  let puffs = [];    // each puff is an object with many "pieces"
  let bubbles = [];  // each bubble is one particle

  // =============================
  // Ambient background bubbles
  // =============================
  const AMBIENT_LANES = 12;            // number of columns/streams
  const AMBIENT_PER_LANE = 6;          // bubbles per lane on screen
  const AMBIENT_X_JITTER = 10;         // px side jitter around lane center
  const AMBIENT_R_MIN = 1.2;
  const AMBIENT_R_MAX = 3.2;
  const AMBIENT_RISE_MIN = 12;         // px/s
  const AMBIENT_RISE_MAX = 35;         // px/s
  const AMBIENT_ALPHA = 0.18;          // overall faintness
  const AMBIENT_WOBBLE = 10;           // px/s wobble strength

  let ambientBubbles = [];

  // =============================
  // Gravel + Decor (cached + depth-sorted)
  // =============================
  const GRAVEL_BAND_FRAC = 0.1;   // bottom 16% of tank
  const GRAVEL_DENSITY = 30;     // higher = more pebbles (tune)
  let gravelCanvas = null;
  let gravelCtx = null;

  let decor = []; // { kind, x, y, scale, depth, layer } layer: "back"|"mid"|"front"

  // =============================
  // Light rays (subtle)
  // =============================
  const RAYS_ENABLED = true;
  const RAY_ALPHA = 0.5;       // keep low
  const RAY_SPEED = 3;          // px/sec drift
  const RAY_COUNT = 40;          // how many bands across
  const RAY_SOFTNESS = 250;     // blur-ish width in px (bigger = softer)
  let rayT = 0;

  let raysCanvas = null;
  let raysCtx = null;
  let raysW = 0, raysH = 0;

  // =============================
  // Canvas setup
  // =============================
  const wrap = document.getElementById("wrap");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  function resizeCanvas() {
    const r = wrap.getBoundingClientRect();
    // Respect devicePixelRatio for crisp sprites while capping at 2x to avoid overdraw cost.
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    canvas._dpr = dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  const W = () => canvas.width / canvas._dpr;
  const H = () => canvas.height / canvas._dpr;

  window.addEventListener("resize", () => {
    resizeCanvas();
    initAmbientBubbles();
    initLightRays();
    rebuildSceneryCaches();
  }, { passive: true });

  resizeCanvas();
  initAmbientBubbles();
  initLightRays();
  rebuildSceneryCaches();


  function rebuildSceneryCaches() {
    buildGravelCache();
    initDecor();
  }

  function buildGravelCache() {
    const w = Math.floor(W());
    const h = Math.floor(H());
    const bandH = Math.floor(h * GRAVEL_BAND_FRAC);

    gravelCanvas = document.createElement("canvas");
    gravelCanvas.width = w;
    gravelCanvas.height = h;
    gravelCtx = gravelCanvas.getContext("2d");

    // Clear
    gravelCtx.clearRect(0, 0, w, h);

    const yTop = h - bandH;

    // Soft transition shadow where gravel meets water
    {
      const grad = gravelCtx.createLinearGradient(0, yTop - 24, 0, yTop + 18);
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0,0.28)");
      gravelCtx.fillStyle = grad;
      gravelCtx.fillRect(0, yTop - 24, w, 42);
    }

    // Pebbles (pre-rendered, cheap at runtime)
    // Count scales with area
    const area = w * bandH;
    const pebCount = Math.floor(area / 260 * GRAVEL_DENSITY);

    gravelCtx.save();
    gravelCtx.globalCompositeOperation = "source-over";

    for (let i = 0; i < pebCount; i++) {
      const x = rand(0, w);
      const y = rand(yTop, h);

      // Pebble size varies slightly
      const r = rand(2.2, 6.5);

      // Bright blue variation but still cohesive
      const hue = rand(190, 205);     // blue-cyan range
      const sat = rand(70, 95);
      const lit = rand(45, 62);

      // Base pebble
      gravelCtx.beginPath();
      gravelCtx.ellipse(x, y, r * rand(0.9, 1.25), r * rand(0.7, 1.1), rand(0, Math.PI), 0, Math.PI * 2);
      gravelCtx.fillStyle = `hsl(${hue} ${sat}% ${lit}%)`;
      gravelCtx.fill();

      // Subtle highlight
      gravelCtx.globalAlpha = 0.22;
      gravelCtx.beginPath();
      gravelCtx.arc(x - r * 0.25, y - r * 0.25, r * 0.35, 0, Math.PI * 2);
      gravelCtx.fillStyle = "rgba(255,255,255,1)";
      gravelCtx.fill();
      gravelCtx.globalAlpha = 1;
    }

    gravelCtx.restore();
  }

  function initDecor() {
    decor = [];

    const w = W(), h = H();
    const bandH = h * GRAVEL_BAND_FRAC;
    const floorY = h - bandH * 0.35;

        // ---------- overlap control ----------
      const placed = []; // {x,y,r,layer,kind}

      function layerFactor(a, b) {
        // same layer = strict, different = more forgiving
        return (a === b) ? 1.0 : 0.55;
      }

      function canPlace(x, y, r, layer, kind) {
        for (const p of placed) {
          const dx = x - p.x;
          const dy = y - p.y;

          const otherKind = p.kind;

          // If either item is coral, use anisotropic spacing (ellipse)
          if (kind === "coral" || otherKind === "coral") {
            // horizontal spacing is the big one for coral
            const sameLayer = (layer === p.layer);

            // Be much less forgiving across layers for coral, or they’ll stack visually
            const layerMul = sameLayer ? 1.0 : 0.85;

            // r here should represent "horizontal claim" for coral
            const minX = (r + p.r) * 1.15 * layerMul;

            // allow a bit of vertical overlap since they sit on the same floor band anyway
            const minY = (r + p.r) * 0.35;

            // ellipse test: (dx/minX)^2 + (dy/minY)^2 >= 1
            const nx = dx / minX;
            const ny = dy / minY;
            if ((nx * nx + ny * ny) < 1) return false;

            continue;
          }

          // Stone vs stone: standard circle spacing
          const minD = (r + p.r) * layerFactor(layer, p.layer);
          if ((dx * dx + dy * dy) < (minD * minD)) return false;
        }
        return true;
      }

      function findSpot(r, layer, kind, xMin, xMax, yMin, yMax, tries = 1000) {
        let best = null;
        let bestScore = -Infinity;

        for (let t = 0; t < tries; t++) {
          const x = rand(xMin, xMax);
          const y = rand(yMin, yMax);

          // If it fits, take it immediately (fast path)
          if (canPlace(x, y, r, layer, kind)) {
            placed.push({ x, y, r, layer, kind });
            return { x, y };
          }

          // Otherwise score it by clearance so fallback is smart, not random
          let minScore = Infinity;

          for (const p of placed) {
            const dx = x - p.x;
            const dy = y - p.y;

            // Use the same spacing model as canPlace for scoring
            if (kind === "coral" || p.kind === "coral") {
              const sameLayer = (layer === p.layer);
              const layerMul = sameLayer ? 1.0 : 0.85;

              const minX = (r + p.r) * 1.15 * layerMul;
              const minY = (r + p.r) * 0.35;

              const nx = dx / minX;
              const ny = dy / minY;

              // >1 is good, <1 is overlap. Higher is better.
              const score = (nx * nx + ny * ny);
              if (score < minScore) minScore = score;
            } else {
              const minD = (r + p.r) * layerFactor(layer, p.layer);
              const d2 = dx*dx + dy*dy;
              const score = d2 / (minD * minD);
              if (score < minScore) minScore = score;
            }
          }

          if (minScore > bestScore) {
            bestScore = minScore;
            best = { x, y };
          }
        }

        // Fallback: place the best of the tried spots (not random)
        if (best) {
          placed.push({ x: best.x, y: best.y, r, layer, kind });
          return best;
        }

        // Absolute worst-case (should never happen unless placed is empty and tries=0)
        const x = rand(xMin, xMax);
        const y = rand(yMin, yMax);
        placed.push({ x, y, r, layer, kind });
        return { x, y };
      }

    const stones = Math.floor(rand(4, 6));
    const corals = Math.floor(rand(3, 6));

    // Stones
    for (let i = 0; i < stones; i++) {
      const depth = rand(0.40, 0.90);
      const layer = depth < 0.55 ? "back" : (depth < 0.78 ? "mid" : "front");

      const scale = rand(0.5, 1.25) * lerp(0.5, 1.25, depth);
      const baseR = 40 * scale;
      const lumps = [];

      const lumpCount = Math.floor(rand(4, 7));
      for (let k = 0; k < lumpCount; k++) {
        const a = (k / lumpCount) * Math.PI * 2 + rand(-0.2, 0.2);
        lumps.push({
          a,
          rMul: rand(0.75, 1.05),
          xMul: rand(0.45, 0.65),
          yMul: rand(0.18, 0.32)
        });
      }

      const stoneR = baseR * 3; // claim a little extra space than the visual blob
      const pos = findSpot(
        stoneR, layer, "stone",
        w * 0.2, w * 0.92,
        floorY - bandH * 0.25, floorY + bandH * 0.12
      );

      decor.push({
        kind: "stone",
        x: pos.x,
        y: pos.y,
        scale,
        depth,
        layer,
        stone: { baseR, lumps }
      });
    }

    // Coral
    for (let i = 0; i < corals; i++) {
      const depth = rand(0.45, 0.92);
      const layer = depth < 0.6 ? "back" : (depth < 0.8 ? "mid" : "front");

      const scale = rand(0.75, 1.35) * lerp(0.75, 1.3, depth);
      const height = 270 * scale;
      const width = 40 * scale;

      const branches = [];
      const branchCount = Math.floor(rand(3, 8));
      for (let k = 0; k < branchCount; k++) {
        const t = (k + 1) / (branchCount + 1);
        const y = -height * t;
        const dir = k % 2 === 0 ? 1 : -1;

        const bx = dir * width * rand(0.35, 0.75);
        const by = y - height * rand(0.08, 0.16);

        branches.push({ y, bx, by, tipR: 6 * scale });
      }

      // Coral needs a BIG spacing radius because it’s tall and has arms
      const coralR = width * 2.2; 

      const pos = findSpot(
        coralR, layer, "coral",
        w * 0.12, w * 0.88,
        floorY - bandH * 0.12, floorY + bandH * 0.06
      );

      decor.push({
        kind: "coral",
        x: pos.x,
        y: pos.y,
        scale,
        depth,
        layer,
        coral: { height, width, branches }
      });
    }
  }

  // =============================
  // Sprite loading
  // =============================
  const sprite = new Image();
  sprite.src = SPRITE_URL;

  let frameW = 0, frameH = 0;
  let useFallback = false;

  sprite.onload = () => {
    frameW = Math.floor(sprite.width / SHEET_COLS);
    frameH = Math.floor(sprite.height / SHEET_ROWS);
    // Only start simulation once assets are ready so sizing is correct.
    initCountdownFish();
    requestAnimationFrame(loop);
    tickMinuteAligned();
  };

  sprite.onerror = () => {
    console.warn("fish.png failed to load. Using fallback circles.");
    frameW = 48; frameH = 24;
    useFallback = true;
    // Start anyway with simple circles so the countdown still works without the sprite.
    initCountdownFish();
    requestAnimationFrame(loop);
    tickMinuteAligned();
  };

  // =============================
  // Fish model
  // =============================
  let fish = [];

  function rand(min, max) { return min + Math.random() * (max - min); }
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  function lerp(a, b, t) { return a + (b - a) * t; }

  // Spawn a puff + bubbles at a point
  function spawnDespawnEffect(x, y, scale = 1) {
    // Puff is made of small circles that expand and fade quickly.
    const pieces = [];
    for (let k = 0; k < PUFF_PIECES; k++) {
      const a = rand(-Math.PI, Math.PI);
      const sp = rand(12, 40) * (0.7 + scale * 0.7); // outward speed
      pieces.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        seed: Math.random() * 10
      });
    }
    puffs.push({
      t: 0,
      life: PUFF_LIFE,
      pieces,
      scale
    });

    // Bubbles are individual particles that rise up and drift.
    const n = Math.floor(rand(BUBBLE_COUNT_MIN, BUBBLE_COUNT_MAX + 1));
    for (let k = 0; k < n; k++) {
      bubbles.push({
        x: x + rand(-6, 6) * scale,
        y: y + rand(-4, 4) * scale,
        vx: rand(-BUBBLE_DRIFT, BUBBLE_DRIFT) * 0.35,
        vy: -rand(BUBBLE_RISE_MIN, BUBBLE_RISE_MAX) * (0.7 + scale * 0.7),
        r: rand(BUBBLE_R_MIN, BUBBLE_R_MAX) * (0.7 + scale * 0.7),
        t: 0,
        life: rand(BUBBLE_LIFE_MIN, BUBBLE_LIFE_MAX)
      });
    }
  }

  function updateEffects(dt) {
    // Update puffs
    for (let i = puffs.length - 1; i >= 0; i--) {
      const p = puffs[i];
      p.t += dt;
      const alive = p.t < p.life;

      // Integrate puff pieces
      for (const pc of p.pieces) {
        pc.x += pc.vx * dt;
        pc.y += pc.vy * dt;
        // light damping so it doesn't explode forever
        pc.vx *= 0.92;
        pc.vy *= 0.92;
      }

      if (!alive) puffs.splice(i, 1);
    }

    // Update bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      b.t += dt;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // gentle sideways wobble
      b.x += Math.sin((b.t * 3.5) + b.r) * 6 * dt;

      if (b.t >= b.life || b.y + b.r < 0) bubbles.splice(i, 1);
    }
  }

  function updateAmbientBubbles(dt) {
    const w = W(), h = H();

    for (const b of ambientBubbles) {
      b.y += b.vy * dt;

      // Gentle sideways wobble around the lane center
      b.phase += dt * 1.5;
      b.x = b.laneX
        + Math.sin(b.phase + b.laneIndex) * (AMBIENT_X_JITTER * 0.8)
        + rand(-0.6, 0.6); // tiny randomness

      // Recycle when it exits the top
      if (b.y + b.r < 0) {
        b.y = h + rand(0, h * 0.15); // respawn slightly below bottom, staggered
        b.r = rand(AMBIENT_R_MIN, AMBIENT_R_MAX);
        b.vy = -rand(AMBIENT_RISE_MIN, AMBIENT_RISE_MAX);
        b.phase = Math.random() * Math.PI * 2;
      }
    }
  }

  function initAmbientBubbles() {
    ambientBubbles = [];
    const w = W(), h = H();

    for (let lane = 0; lane < AMBIENT_LANES; lane++) {
      const laneX = ((lane + 0.5) / AMBIENT_LANES) * w;

      for (let k = 0; k < AMBIENT_PER_LANE; k++) {
        ambientBubbles.push(makeAmbientBubble(laneX, h, lane));
      }
    }
  }

  function makeAmbientBubble(laneX, h, laneIndex) {
    return {
      laneX,
      laneIndex,
      // Start staggered through the height so you see a steady stream immediately
      x: laneX + rand(-AMBIENT_X_JITTER, AMBIENT_X_JITTER),
      y: rand(0, h),
      r: rand(AMBIENT_R_MIN, AMBIENT_R_MAX),
      vy: -rand(AMBIENT_RISE_MIN, AMBIENT_RISE_MAX),
      phase: Math.random() * Math.PI * 2
    };
  }

  function initLightRays() {
    if (!RAYS_ENABLED) return;

    const w = W(), h = H();
    raysW = w * 5;   // match tank width for clean coverage
    raysH = h * 3;   // match tank height

    raysCanvas = document.createElement("canvas");
    raysCanvas.width = raysW;
    raysCanvas.height = raysH;
    raysCtx = raysCanvas.getContext("2d");

    const c = raysCtx;
    c.clearRect(0, 0, raysW, raysH);

    // Rays: long diagonal bands built from soft gradients (no per-frame jitter)
    const spacing = raysW / RAY_COUNT;
    const angle = .3; // radians-ish tilt; small negative = slant left
    c.save();
    c.translate(raysW * 0.5, -h);
    c.rotate(angle);
    c.translate(-raysW * 0.5, 0);

    for (let i = -2; i < RAY_COUNT + 2; i++) {
      const x = i * spacing + spacing * 0.5;

      const g = c.createLinearGradient(x - RAY_SOFTNESS, 0, x + RAY_SOFTNESS, 0);
      g.addColorStop(0.0, "rgba(255,255,255,0)");
      g.addColorStop(0.45, "rgba(255,255,255,0.06)");
      g.addColorStop(0.50, "rgba(255,255,255,0.25)");
      g.addColorStop(0.55, "rgba(255,255,255,0.06)");
      g.addColorStop(1.0, "rgba(255,255,255,0)");

      c.fillStyle = g;
      c.fillRect(x - RAY_SOFTNESS, 0, RAY_SOFTNESS * 2, raysH);
    }

    c.restore();
  }

  function makeFish() {
    const s = rand(SCALE_MIN, SCALE_MAX);
    const speed = rand(MAX_SPEED_MIN, MAX_SPEED_MAX) * (0.7 + s * 0.6);

    const a = rand(-Math.PI, Math.PI);
    const vx = Math.cos(a) * speed;
    const vy = Math.sin(a) * speed;

    return {
      x: rand(10, W() - 10),
      y: rand(10, H() - 10),
      vx, vy,
      maxSpeed: speed,
      turnRate: rand(TURN_RATE_MIN, TURN_RATE_MAX),

      wanderAngle: rand(-Math.PI, Math.PI),
      pauseT: 0,

      frame: Math.floor(Math.random() * FRAMES_TOTAL),
      frameT: Math.random() * (1 / ANIM_FPS),

      scale: s,
      facing: 1
    };
  }

  let userInteracted = false;
  wrap.addEventListener("pointerdown", () => { userInteracted = true; }, { passive: true });

  function playPoofSfx() {
    try {
      if (sfxPoof.readyState < 2) sfxPoof.load(); // ensure it’s loaded
      sfxPoof.pause();
      sfxPoof.currentTime = 0;
      const p = sfxPoof.play();
      if (p && p.catch) p.catch(e => console.log("SFX play failed:", e));
    } catch (e) {
      console.log("SFX exception:", e);
    }
  }

  function setFishCount(target) {
    // target can be 0..MAX_FISH_CAP
    const t = clamp(Math.floor(target), 0, MAX_FISH_CAP);

    if (t === fish.length) return;

    if (t < fish.length) {
      let poofPlayed = false;
      // Remove fish one at a time so we can spawn an effect at the removed fish's position.
      while (fish.length > t) {
        // Remove a random fish so the effect appears in different places.
        const idx = Math.floor(Math.random() * fish.length);
        const removed = fish[idx];

        // Swap-remove (fast): move last fish into idx, then pop.
        fish[idx] = fish[fish.length - 1];
        fish.pop();

        // Spawn puff + bubbles where that fish disappeared.
        spawnDespawnEffect(removed.x, removed.y, removed.scale);
        if (!poofPlayed) { playPoofSfx(); poofPlayed = true; }
      }
      return;
    }

    // add fish
    const toAdd = t - fish.length;
    for (let i = 0; i < toAdd; i++) fish.push(makeFish());
  }

  function initCountdownFish() {
    const { left, homeMinutes } = minutesLeftUntilHome();
    const minutesLeft = clamp(left, 0, MAX_FISH_CAP);
    setFishCount(minutesLeft);

    const homeStr = minutesToTimeString(homeMinutes);
    document.getElementById("fish-left").textContent = String(minutesLeft);
  }

  // =============================
  // Spatial hashing
  // =============================
  let grid = new Map();
  function gridKey(cx, cy) { return cx + "," + cy; }
  function gridClear() { grid.clear(); }

  function gridInsert(i, fx, fy) {
    const cx = Math.floor(fx / CELL_SIZE);
    const cy = Math.floor(fy / CELL_SIZE);
    const k = gridKey(cx, cy);
    let arr = grid.get(k);
    if (!arr) { arr = []; grid.set(k, arr); }
    arr.push(i);
  }

  function gridNeighbors(fx, fy) {
    const cx = Math.floor(fx / CELL_SIZE);
    const cy = Math.floor(fy / CELL_SIZE);
    const out = [];
    // Check the 3x3 neighborhood to keep separation O(n) overall.
    for (let y = cy - 1; y <= cy + 1; y++) {
      for (let x = cx - 1; x <= cx + 1; x++) {
        const arr = grid.get(gridKey(x, y));
        if (arr) out.push(arr);
      }
    }
    return out;
  }

  // =============================
  // Steering helpers
  // =============================
  function steerTowardVelocity(f, desiredVx, desiredVy, dt) {
    const curA = Math.atan2(f.vy, f.vx);
    const desA = Math.atan2(desiredVy, desiredVx);

    let da = desA - curA;
    while (da > Math.PI) da -= 2 * Math.PI;
    while (da < -Math.PI) da += 2 * Math.PI;

    const maxTurn = f.turnRate * dt;
    // Limit turn rate to avoid instant heading flips; gives fish inertia.
    da = clamp(da, -maxTurn, maxTurn);
    const newA = curA + da;

    const sp = Math.hypot(f.vx, f.vy);
    f.vx = Math.cos(newA) * sp;
    f.vy = Math.sin(newA) * sp;
  }

  function limitSpeed(f, targetMax) {
    const sp = Math.hypot(f.vx, f.vy);
    if (sp < 0.0001) {
      // If nearly stopped, kick with a small random nudge to avoid stagnation.
      const a = rand(-Math.PI, Math.PI);
      f.vx = Math.cos(a) * targetMax * 0.3;
      f.vy = Math.sin(a) * targetMax * 0.3;
      return;
    }
    if (sp > targetMax) {
      const m = targetMax / sp;
      f.vx *= m;
      f.vy *= m;
    }
  }

  // =============================
  // Update + Draw
  // =============================
  function update(dt) {
    const w = W(), h = H();

    // Rebuild spatial grid each frame for separation queries.
    gridClear();
    for (let i = 0; i < fish.length; i++) gridInsert(i, fish[i].x, fish[i].y);

    for (let i = 0; i < fish.length; i++) {
      const f = fish[i];

      // Occasionally pause a fish to add life; pauseT counts down.
      if (f.pauseT <= 0 && Math.random() < PAUSE_CHANCE_PER_SEC * dt) {
        f.pauseT = rand(PAUSE_MIN, PAUSE_MAX);
      }

      // Wander introduces a slowly varying desired heading.
      f.wanderAngle += rand(-1, 1) * WANDER_JITTER * dt;

      const curA = Math.atan2(f.vy, f.vx);
      const desA = curA + Math.sin(f.wanderAngle) * WANDER_STRENGTH * 0.35;

      let desiredVx = Math.cos(desA);
      let desiredVy = Math.sin(desA);

      // Wall avoidance
      let ax = 0, ay = 0;
      if (f.x < WALL_AVOID_DIST) ax += (WALL_AVOID_DIST - f.x) / WALL_AVOID_DIST;
      if (f.x > w - WALL_AVOID_DIST) ax -= (f.x - (w - WALL_AVOID_DIST)) / WALL_AVOID_DIST;
      if (f.y < WALL_AVOID_DIST) ay += (WALL_AVOID_DIST - f.y) / WALL_AVOID_DIST;
      if (f.y > h - WALL_AVOID_DIST) ay -= (f.y - (h - WALL_AVOID_DIST)) / WALL_AVOID_DIST;

      if (ax || ay) {
        desiredVx += ax * WALL_AVOID_FORCE;
        desiredVy += ay * WALL_AVOID_FORCE;
      }

      // Separation: push away from nearby fish inside SEP_RADIUS using grid neighbors.
      let sx = 0, sy = 0;
      const neighCells = gridNeighbors(f.x, f.y);
      const r2 = SEP_RADIUS * SEP_RADIUS;

      for (const cellArr of neighCells) {
        for (const j of cellArr) {
          if (j === i) continue;
          const o = fish[j];
          const dx = f.x - o.x;
          const dy = f.y - o.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > 0 && d2 < r2) {
            const d = Math.sqrt(d2);
            const push = (SEP_RADIUS - d) / SEP_RADIUS;
            sx += (dx / d) * push;
            sy += (dy / d) * push;
          }
        }
      }

      if (sx || sy) {
        desiredVx += sx * SEP_FORCE;
        desiredVy += sy * SEP_FORCE;
      }

      // Normalize desired
      const mag = Math.hypot(desiredVx, desiredVy) || 1;
      desiredVx /= mag;
      desiredVy /= mag;

      // Target speed
      let targetSpeed = f.maxSpeed;
      if (f.pauseT > 0) {
        f.pauseT -= dt;
        targetSpeed *= PAUSE_SLOWDOWN;
      }

      // Smoothly rotate current velocity toward desired heading.
      steerTowardVelocity(f, desiredVx, desiredVy, dt);

      const curSp = Math.hypot(f.vx, f.vy) || 0.0001;
      const sp = curSp + (targetSpeed - curSp) * clamp(4.0 * dt, 0, 1);
      const a = Math.atan2(f.vy, f.vx);
      f.vx = Math.cos(a) * sp;
      f.vy = Math.sin(a) * sp;

      limitSpeed(f, f.maxSpeed);

      f.x += f.vx * dt;
      f.y += f.vy * dt;

      // Simple wall bounce to keep fish inside the tank.
      if (f.x < 0) { f.x = 0; f.vx = Math.abs(f.vx); }
      if (f.x > w) { f.x = w; f.vx = -Math.abs(f.vx); }
      if (f.y < 0) { f.y = 0; f.vy = Math.abs(f.vy); }
      if (f.y > h) { f.y = h; f.vy = -Math.abs(f.vy); }

      // Animate frame
      f.frameT += dt;
      const frameStep = 1 / ANIM_FPS;
      while (f.frameT >= frameStep) {
        f.frameT -= frameStep;
        f.frame = (f.frame + 1) % FRAMES_TOTAL;
      }
    }
  }

  function drawBubbles() {
    if (!bubbles.length) return;

    ctx.save();
    ctx.globalCompositeOperation = "lighter"; // makes bubbles feel "glowy"
    ctx.lineWidth = 1;

    for (const b of bubbles) {
      const t = clamp(b.t / b.life, 0, 1);
      const alpha = (1 - t) * 0.55;

      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(200,235,255,1)";
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPuffs() {
    if (!puffs.length) return;

    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const p of puffs) {
      const t = clamp(p.t / p.life, 0, 1);
      const alpha = (1 - t) * 0.65;
      const r = lerp(PUFF_START_R, PUFF_END_R, t) * (0.7 + p.scale * 0.7);

      ctx.globalAlpha = alpha;

      for (const pc of p.pieces) {
        ctx.beginPath();
        ctx.arc(pc.x, pc.y, r * rand(0.65, 1.0), 0, Math.PI * 2);
        ctx.fillStyle = "rgba(220,245,255,1)";
        ctx.fill();
      }
    }

    ctx.restore();
  }

  function drawAmbientBubbles() {
    if (!ambientBubbles.length) return;

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = AMBIENT_ALPHA;
    ctx.lineWidth = 1;

    for (const b of ambientBubbles) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(200,235,255,1)";
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawGravel() {
    if (!gravelCanvas) return;
    ctx.drawImage(gravelCanvas, 0, 0);
  }

  function drawStone(d) {
    const s = d.stone;
    const baseR = s.baseR;

    ctx.save();
    ctx.translate(d.x, d.y);

    const shade = lerp(1, 1, d.depth);
    ctx.fillStyle = `rgba(55, 75, 95, ${1 * shade})`;

    ctx.beginPath();
    for (const L of s.lumps) {
      const r = baseR * L.rMul;
      const x = Math.cos(L.a) * baseR * L.xMul;
      const y = Math.sin(L.a) * baseR * L.yMul;
      ctx.moveTo(x + r, y);
      ctx.arc(x, y, r, 0, Math.PI * 2);
    }
    ctx.fill();

    ctx.globalAlpha = 0.16;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.beginPath();
    ctx.ellipse(-baseR * 0.25, -baseR * 0.18, baseR * 0.45, baseR * 0.28, -0.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawCoral(d) {
    const c = d.coral;

    ctx.save();
    ctx.translate(d.x, d.y);

    const alpha = lerp(0.65, 0.9, d.depth);
    ctx.strokeStyle = `rgba(255, 120, 160, ${1 * alpha})`;
    ctx.lineWidth = 5 * d.scale;
    ctx.lineCap = "round";

    // Main stem
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -c.height);
    ctx.stroke();

    // Branches
    for (const b of c.branches) {
      ctx.beginPath();
      ctx.moveTo(0, b.y);
      ctx.lineTo(b.bx, b.by);
      ctx.stroke();

      ctx.globalAlpha = 0.20 * alpha;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.arc(b.bx, b.by, b.tipR, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawDecorItem(d) {
    if (d.kind === "stone") drawStone(d);
    else if (d.kind === "coral") drawCoral(d);
  }

  function draw() {
    const w = W(), h = H();
    ctx.clearRect(0, 0, w, h);

    // Light rays (very subtle, animated by shifting a pre-rendered texture)
    if (RAYS_ENABLED && raysCanvas) {
      rayT += DT;
      const drift = (rayT * RAY_SPEED) % raysW;

      ctx.save();
      ctx.globalCompositeOperation = "screen"; // brightens without harsh white
      ctx.globalAlpha = RAY_ALPHA;

      // tile twice for seamless wrap
      ctx.drawImage(raysCanvas, -drift, 0, raysW, raysH);
      ctx.drawImage(raysCanvas, -drift + raysW, 0, raysW, raysH);

      // fade rays with depth (stronger near top)
      const w = W(), h = H();
      const fade = ctx.createLinearGradient(0, 0, 0, h);
      fade.addColorStop(0.0, "rgba(255,255,255,1)");
      fade.addColorStop(0.55, "rgba(255,255,255,0.35)");
      fade.addColorStop(1.0, "rgba(255,255,255,0)");
      ctx.globalCompositeOperation = "destination-in";
      ctx.fillStyle = fade;
      ctx.fillRect(0, 0, w, h);

      ctx.restore();
    }

    drawAmbientBubbles();
    drawBubbles();

    // Gravel is a cached background layer.
    drawGravel();

    // Build render list: decor + fish, sort by depth (small = far)
    const render = [];

    for (const d of decor) {
      render.push({ type: "decor", depth: d.depth, item: d });
    }

    for (let i = 0; i < fish.length; i++) {
      // Use scale as fish depth (cleanest with your current setup)
      render.push({ type: "fish", depth: fish[i].scale, item: fish[i] });
    }

    render.sort((a, b) => a.depth - b.depth);

    // Draw in sorted order
    for (const r of render) {
      if (r.type === "decor") {
        drawDecorItem(r.item);
        continue;
      }

      // ---- existing fish draw code, but using r.item as f ----
      const f = r.item;

      const drawW = frameW * f.scale;
      const drawH = frameH * f.scale;

      const fx = f.frame % SHEET_COLS;
      const fy = Math.floor(f.frame / SHEET_COLS);
      const sx = fx * frameW;
      const sy = fy * frameH;

      ctx.save();
      ctx.translate(f.x, f.y);

      // Facing hysteresis prevents rapid flipping around zero velocity.
      if (f.vx >  FLIP_EPS) f.facing = 1;
      if (f.vx < -FLIP_EPS) f.facing = -1;

      ctx.scale(f.facing, 1);

      // Tilt in sprite space
      const tiltAngle = Math.atan2(f.vy, f.vx * f.facing);
      const tilt = clamp(tiltAngle, -0.55, 0.55);
      ctx.rotate(tilt);

      if (useFallback) {
        // Simple ellipse stand-in if sprites fail to load.
        ctx.globalAlpha = 0.75;
        ctx.beginPath();
        ctx.ellipse(0, 0, drawW * 0.45, drawH * 0.35, 0, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.fill();
      } else {
        ctx.drawImage(sprite, sx, sy, frameW, frameH, -drawW/2, -drawH/2, drawW, drawH);
      }

      ctx.restore();
    }

    drawPuffs();

    // Vignette to darken edges and focus attention toward the center.
    const g = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.2, w/2, h/2, Math.max(w,h)*0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.28)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);
  }

  // =============================
  // Fixed timestep loop @ 24 fps
  // =============================
  let last = 0;
  let acc = 0;

  function loop(t) {
    const now = t / 1000;
    if (!last) last = now;

    let delta = now - last;
    last = now;
    delta = Math.min(delta, 0.25);

    acc += delta;
    while (acc >= DT) {
      update(DT);
      updateEffects(DT);
      updateAmbientBubbles(DT);
      acc -= DT;
  }

    draw();
    requestAnimationFrame(loop);
  }

  // =============================
  // Minute-aligned countdown tick
  // =============================
  function updateCountdownAndFish() {
    const { left, homeMinutes } = minutesLeftUntilHome();
    const minutesLeft = clamp(left, 0, MAX_FISH_CAP);

    setFishCount(minutesLeft);

    const homeStr = minutesToTimeString(homeMinutes);
    document.getElementById("fish-left").textContent = String(minutesLeft);
  }

  function tickMinuteAligned() {
    // Update fish count on the minute boundary to stay in sync with real time.
    updateCountdownAndFish();

    const now = new Date();
    const msToNextMinute = (60 - now.getSeconds()) * 1000 - now.getMilliseconds();
    const delay = msToNextMinute <= 0 ? 1000 : msToNextMinute;
    setTimeout(tickMinuteAligned, delay);
  }

  function getPacificTodayAndTomorrowKeys() {
    const pac = getPacificComponents();
    const todayKey = getPacificDateKey(pac);

    // Add 1 calendar day in Pacific terms by using a Date and setDate(),
    // then re-format in Pacific.
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const formatter = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/Los_Angeles",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });

    const parts = formatter.formatToParts(tomorrow);
    const get = type => parts.find(p => p.type === type).value;

    const pacTomorrow = {
      year: Number(get("year")),
      month: Number(get("month")),
      day: Number(get("day"))
    };

    const tomorrowKey = getPacificDateKey(pacTomorrow);
    return { todayKey, tomorrowKey };
  }

  // =============================
  // Audio Settings
  // =============================

  // ---- Gapless background loop via Web Audio ----
  let audioCtx = null;
  let bgGain = null;
  let bgSource = null;
  let bgBuffer = null;
  let bgCtxReady = false;

  async function ensureAudioContext() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    bgGain = audioCtx.createGain();
    bgGain.gain.value = 0; // will be set by applyAudioSettings()
    bgGain.connect(audioCtx.destination);
  }

  // Call this after a user gesture (click/tap) to satisfy autoplay rules
  async function ensureBgBufferLoaded() {
    if (bgBuffer) return;
    await ensureAudioContext();

    const resp = await fetch("water-ambience.mp3");
    if (!resp.ok) throw new Error("Failed to load water-ambience.mp3");
    const arr = await resp.arrayBuffer();
    bgBuffer = await audioCtx.decodeAudioData(arr);
  }

  function startBgLoopIfNeeded() {
    if (!audioCtx || !bgBuffer) return;
    if (bgSource) return; // already playing

    bgSource = audioCtx.createBufferSource();
    bgSource.buffer = bgBuffer;
    bgSource.loop = true;

    // Optional: if your file has a tiny dead lead-in/out, you can trim it with loop points:
    // bgSource.loopStart = 0.02;
    // bgSource.loopEnd = bgBuffer.duration - 0.02;

    bgSource.connect(bgGain);
    bgSource.start();
    bgSource.onended = () => { bgSource = null; };
  }

  function stopBgLoop() {
    if (!bgSource) return;
    try { bgSource.stop(); } catch {}
    bgSource = null;
  }

  // =============================
  // Settings UI wiring
  // =============================
  const settingsBtn = document.getElementById("settings-btn");
  const settingsPanel = document.getElementById("settings-panel");

  const homeTimeInput = document.getElementById("home-time");
  const homeDaySelect = document.getElementById("home-day");

  const settingsSaveBtn = document.getElementById("settings-save");
  const settingsCancelBtn = document.getElementById("settings-cancel");

  const bgAudio = document.getElementById("bg-audio");
  const sfxPoof = document.getElementById("sfx-poof");

  const bgMuteBtn = document.getElementById("bg-mute");
  const bgVolSlider = document.getElementById("bg-vol");
  const sfxMuteBtn = document.getElementById("sfx-mute");
  const sfxVolSlider = document.getElementById("sfx-vol");

  function openSettingsPanel() {
    const pac = getPacificComponents();
    const { tomorrowKey } = getPacificTodayAndTomorrowKeys();
    const s = getTargetSettings(pac);

    homeTimeInput.value = minutesToTimeString(s.homeMinutes);
    homeDaySelect.value = (s.targetDate === tomorrowKey) ? "tomorrow" : "today";

    applyAudioSettings();
    ensureBgAudioStarted();

    settingsPanel.classList.remove("hidden");
  }

  function closeSettingsPanel() {
    settingsPanel.classList.add("hidden");
  }

  function saveSettingsFromPanel() {
    const homeStr = homeTimeInput.value;
    const homeMinutes = timeStringToMinutes(homeStr);
    if (homeMinutes === null) {
      alert("Please enter a valid end time (H).");
      return;
    }

    const { todayKey, tomorrowKey } = getPacificTodayAndTomorrowKeys();
    const targetDate = (homeDaySelect.value === "tomorrow") ? tomorrowKey : todayKey;

    saveTargetSettings(targetDate, homeMinutes);

    closeSettingsPanel();
    updateCountdownAndFish();
  }

  let audioSettings = loadAudioSettings();

  function applyAudioSettings() {
    // BG (WebAudio)
    if (bgGain) {
      const vol = audioSettings.bgMuted ? 0 : audioSettings.bgVol;
      bgGain.gain.value = vol;
    }

    // SFX (HTMLAudio)
    sfxPoof.volume = audioSettings.sfxVol;
    sfxPoof.muted = audioSettings.sfxMuted;

    bgMuteBtn.textContent = audioSettings.bgMuted ? "Unmute" : "Mute";
    sfxMuteBtn.textContent = audioSettings.sfxMuted ? "Unmute" : "Mute";

    bgVolSlider.value = Math.round(audioSettings.bgVol * 100);
    sfxVolSlider.value = Math.round(audioSettings.sfxVol * 100);
  }

  let bgStarted = false;
  async function ensureBgAudioStarted() {
    try {
      await ensureBgBufferLoaded();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      startBgLoopIfNeeded();
      bgStarted = true;
      applyAudioSettings();
    } catch {
      // If this fails, it’ll usually be because user gesture hasn’t happened yet.
    }
  }

  wrap.addEventListener("pointerdown", () => {
    applyAudioSettings();
    ensureBgAudioStarted();
  }, { passive: true });

  bgMuteBtn.addEventListener("click", () => {
    audioSettings.bgMuted = !audioSettings.bgMuted;
    saveAudioSettings(audioSettings);
    applyAudioSettings();
    ensureBgAudioStarted();
  });

  sfxMuteBtn.addEventListener("click", () => {
    audioSettings.sfxMuted = !audioSettings.sfxMuted;
    saveAudioSettings(audioSettings);
    applyAudioSettings();
  });

  bgVolSlider.addEventListener("input", () => {
    audioSettings.bgVol = clamp(Number(bgVolSlider.value) / 100, 0, 1);
    saveAudioSettings(audioSettings);
    applyAudioSettings();
    ensureBgAudioStarted();
  });

  sfxVolSlider.addEventListener("input", () => {
    audioSettings.sfxVol = clamp(Number(sfxVolSlider.value) / 100, 0, 1);
    saveAudioSettings(audioSettings);
    applyAudioSettings();
  });

  settingsBtn.addEventListener("click", () => {
    if (settingsPanel.classList.contains("hidden")) openSettingsPanel();
    else closeSettingsPanel();
  });

  settingsSaveBtn.addEventListener("click", saveSettingsFromPanel);
  settingsCancelBtn.addEventListener("click", closeSettingsPanel);

})();
</script>
</body>
</html>
